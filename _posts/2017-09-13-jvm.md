---
layout: post
title:  "JVM学习(一)　JVM内存分布"
categories: JVM
tags:  JVM
author: Lzg
---

*JVM是用来执行java程序的*

`JVM`虚拟机运行时管理的内存区域有以下几块：
* `程序计数器` 　它在内存中只会分配一块很小的区域，用来保存当前线程的上下文信息，以便于线程的切换．它是`线程私有`的
* `虚拟机栈`　同样它也是`线程私有`的，它的生命周期与线程相同，　其描述的意思是`Java方法执行的内存模型`,　每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，　操作数栈，动态链接，方法出口等．一个方法的执行对应着一个栈帧在虚拟机栈中的入栈到出栈的过程．　局部变量表存放着各种编译可知的基础数据类型还有引用类型．它所需的内存空间在编译完成的时候就被确定下来．

  如果线程请求的栈深度大于允许的，则抛出`stackoverflowError`
  当前虚拟机栈可以动态拓展，如果申请不到足够的内存,则抛出`outofmemoryError`.
* `本地方法栈` 和上面的栈很类似，顾名思义，它描述的是虚拟机执行`native`方法．

***

* `堆`　这是被所有`线程共享`的区域，几乎所有的对象实例以及数组都在这里分配．同时堆是`GC`主要作用的区域，由于现代收集器基本采用分代算法，所有堆还可以分为`Eden`, `from survior` `to survoir`　和`permanent gen`区域．当没有内存分配的时候，会抛出`outofmemoryError`.
 我们可以通过`-Xmx` `-Xms`来控制堆空间的大小
* `方法区`　和上面的堆一样，也是`线程共享`的．它用来存储`已经被虚拟机加载的类信息，常量池，静态变量，即时编译器编译后的代码等数据`．逻辑上算堆的一部分！也可以说成是永生代，不过现在hotspot团队有取代永生代的趋势．．
在这个区域的回收是比较困难的，她主要是针对常量池的回收和类型卸载．

　　`运行时常量池` 是方法区的一部分！　Class文件中除了有类版本，字段，　方法，接口等描述信息外，还有一项就是常量池．它用来存放`编译期间生成的各种字面量和符号引用`，它们将在类加载后进入常量区存放．

* `直接内存` 不是虚拟机运行的一部分，nio调用native函数直接分配堆外的内存，然后Java通过存储在堆上的`DirectByteBuffer`对象操纵，在某些场景提高性能(?)，　避免在Java堆和native堆来回复制数据．

**对象创建的过程**

  * 首先虚拟机遇到new指令，会先去指令的参数能否在常量池中定位到一个符号引用，　并检查是否已经被加载，解析，初始化．如果没有就加载
  * 检查后为新生对象分配内存．对象所需的空间在记载完成后就被确定下来，划分空间有两种方式:
  * 1 指针碰撞．　假设内存空间是完整的，　中间放一个指针作为分割，分配的时候将指针向未被分配的区域移动等大小的空间
  * ２　空闲列表．　内存不是连续的，虚拟机使用一个free list维护可用内存，分配的时候找到足够的空间分配，并更新列表．
  * 内存分配完成后需要将其空间都初始化为零值，接下来对对象头进行设置，　比如说类的元数据，对象的哈兮码，　对象ＧＣ分代年龄等．
  `对象头还存储着类型指针`，　虚拟机通过它判断是哪个类的实例，当然并不是所有虚拟机都保存这个指针．如果对象是数组，则还需要保存记录长度的数据．
  * 到这一步仅仅是创建了新对象，<init>方法还没执行，　所有字段还都是零，　在执行new之后会执行init方法，将对象按照程序员意愿初始化．这样的一个对象才是可用的．

  ***

  **对象定位**

   * 句柄．堆划分一块用作句柄池，reference保存着句柄的地址，而句柄包含着对象实例数据和类型数据的具体地址．好处时对象被移动的时候(GC)不只需要修改句柄中的实例数据指针
   * 直接指针．reference直接保存着对象的地址．速度快．

****

* 调整堆空间大小　`-Xmx20m` `-Xms20m`
* 栈空间大小　`-Xss128k`
* 方法区（永生代) `-XX:PermSize=10M -XX:MaxPermSize=10M`



se:gc -XX:+PrintGCDetails 打印GC信息

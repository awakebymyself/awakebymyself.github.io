---
layout: post
title:  "JVM学习之内存模型"
categories: JVM
tags:  jvm
author: Lzg
---

*什么是内存模型*

 JVM为了屏蔽不同平台已经硬件在程序访问内存造成的一些差异性, java虚拟机规范定义了一套运行于java
 虚拟机平台的访问内存的抽象过程, 这就是内存模型.

 *那么这个模型的具体内容是指什么呢?*

    首先我们需要知道的是在现在的计算机架构中,我们会在处理器和内存中间加上一层高速缓存,这是因为
    处理器的速度和内存IO速度之间存在着几个数量级的差异,所以我们处理器在计算完后会把数据复制到
    高速缓存上,最后再刷新回内存.
     而在我们java虚拟机中, 这个内存可以想象成我们的主存, 而高速缓存可以当成我们的工作内存,
     他是存在于每个线程中的.

  关于主存和工作内存间的交互协议.
  JVM规定了下面八种操作, 他们 保证了必须是原子性,而且有一定的顺序!

  `lock`作用于主存变量, 将他标志为一个线程独占
  `unlock`将一个主存变量释放,才能被其他线程使用
  `read` 将主存变量传输到工作内存中,供以后的load使用
  `load`将从主存中得到的变量值放入工作内存的变量副本
  `use` 将工作内存中的副本变量包传递到工作引擎,交给程序使用
  `assign` 将工作引擎得到的数值赋值给工作内存的副本变量,以供后面刷新到主存中使用
  `store` 把工作内存变量值传输到主存中,供给后面的write
  `write` 将从工作内存中得到的值放入主存变量中

 这八种操作和volatile 规则确定了哪些内存访问操作在并发下是安全的

  `volatile` 他保证了变量赋值操作的顺序与代码的顺序一致.

  * 被这个修饰的变量在线程读取更新的时候会*立即*被刷新回主存, 所以在多线程下面能够保证可见性, 虽然普通
  的变量也可以,但是主要不是立即!
  * 还能禁止编译器的指令重排序! 通过的手段是添加一个内存屏障, 后面的指令不能到屏障前面去.
  这是即使编译器的优化手段, 比如有三个操作 a,b,c a and b 必须保持先后顺序,但是和c没有关系,所以
  c可以吧c提前到a之前执行,只要不影响最终结果. 会让其他线程刷新主存

*内存模型的描述可以分类为原子性, 可见性, 有序性的描述*
  `原子性` 上面定义的八种操作满足了原子性, 对于基本类型的数值操作是原子性的, 而long, double的64位数值
  会分别两部操作, 但是虚拟机一般将其实现为原子性操作.如果更大范围的原子性可以通过monitorenter 和
  moniterexit两个字节码指令保证,就是相当于synchronized.

  `可见性`  volatile 保证了可见性, 不过synchronized也保证了可见性, 这是因为对一个变量进行unlock
  之前必须先把这个变量刷新回主存, 执行store.write操作.
  注意, final也能保证可见性, 这是因为被final修饰的类变量在构造器中被初始化之后,如果this引用没有逃逸
  ,那么其他线程就可以访问这个final字段的值(逃逸的话可能访问的对象没有被初始化好)
  `有序性`  java线程中天然有序性: 在本线程中观察的所有操作都是有序的, 但是如果从一个i哦线程观察另外
  一个线程,那么就是无序的.
前面半句指出了线程内表现为串行的语义, 后半句指出了指令重排序和工作内存以及主内存的同步延迟现象
所以可以通过volatile和synchronized保证!

*Happen before 原则!*

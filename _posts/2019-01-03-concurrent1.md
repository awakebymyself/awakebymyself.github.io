---
layout: post
title:  "并发基础关键字解读"
categories: concurrent
tags:  concurrent
author: Lzg
---

* content
{:toc}

---

# 并发编程的性能挑战

`上下文切换` : 当多个线程运行的时候cpu通过线程调度算法给给每个线程分配时间片，一般是几十ms，当一个线程执行完时间片之后会切换到下一个线程。在切换前会保存当前任务的状态以便下次切回来的时候能继续任务。

`如何避免？` ：
 1. 减少线程数量
 2. 无锁并发编程。多线程竞争锁的时候会引起阻塞，重新恢复的时候会引起上下文切换。
 3. CAS算法更新数据，不需要持有锁。java的`Atomic`包
 4. 协程， 单线程里多任务调度，单线程里多任务切换

`死锁` : 比如说两个线程都持有一把锁，并等待对方释放锁
`避免`：
  1. 避免一个线程获取多个锁
  2. 获取锁顺序保持一致
  3. 尝试使用定时锁， lock.trylock(..)
  4. 避免一个线程在锁内占用过多资源，缩小锁代码路径

`资源限制` ：硬件限制比如说带宽上传下载，磁盘读写等等，软件限制比如说socket连接数和数据库连接数。
`避免`:
  1. 硬件资源问题可以加配置或者搭载集群
  2. 软件资源问题可以用资源池


# 并发基础关键字解读

***volatile***

作用：保证可见性和顺序性，不能保证原子性。一个线程对变量的改会通知的其他的读线程。另外它还能抑制编译器的优化，指令重排序。它比`synchronized`执行成本低，因为不会引起线程调度和上下文切换。

`实现原理:`
一般处理器都不直接和系统内存打交道，而是将值读到L1,L2这些高速缓存中。
在对`volatile`变量进行写操作的时候，虚拟机会发送带有lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存，写回的操作会使其他线程缓存在该值的内存地址失效（修改了内存地址）。
其他缓存了该值的处理器通过总线嗅探到自己缓存的值是过期了（实现了缓存一致性协议MESI），在下次读的时候从主存中重新读并缓存。


***synchronized***

作用： 保证原子性和可见性以及顺序性

使用方法：java中每个对象都可以作为锁。
 1. 对于普通同步方法，锁的是当前实例对象 this
 2. 静态同步方法， 锁的是当前Class对象
 3. 同步方法块， 锁的是括号里的对象


`实现原理:`
首先对象在内存中可以分为三块，对象头，实例数据、和padding（对齐）
对象头分为markWord， 保存的是hashcode.分代年龄，持有锁
每个对象都有一个与之关联的monitor锁。

* 对于代码块，虚拟机会在代码前后或者异常处加上`monitorenter` 和`moniterexit`指令，当执行到这条指令的时候会向当前对象请求monitor对象。
* 对于同步方法，其常量池中多了`ACC_SYNCHRONIZED`标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了执行线程将先获取monitor

如果当前monitor的进入数为0，则说明monitor未被占用，则当前线程占有该monitor，同时monitor的进入数变为1。
如果当前monitor进入数不为0，且monitor的占用者是当前线程，则可以重复占用该monitor，同时进入数加1。
如果其他线程占有了该monitor，则线程进入阻塞状态，直到monitor的进入数重新变为0，再重新尝试获取所有权

 > monitor本质就是一个同步工具，提供互斥的访问。

 > CPU总线，是PC系统中最快的总线，也是芯片组与主板的核心。这条总线主要由CPU使用，用来与高速缓存、主存和北桥（或MCH）之间传送信息

***final***

作用: 修改的对象不可变，类不能被继承，方法不能重写

对于final域要遵守重排序规则:
 1. 在 构造器内对final写和将这个构造器的引用赋值给其他引用直接不能重排序，即拿到的这个对象引用其final域是已经正确初始化了。实现方式则是在final域写入之后，构造函数return之前插入一个内存屏障，禁止处理器重排序

 2. 初次读包含final域的对象引用与读final域直接不能重排序，保证正确初始化

`实现方式`:编译器插入内存屏障，禁止处理器重排序


***happens-before***

作用：`JMM` 通过这个规则保证如果操作A对于操作B满足条件，那么不管A和B是否在一个线程，A的操作结果都对B可见。这是内存模型的保证

具体内容：
 1. 一个线程的操作都`happens-before`这个线程后续的操作
 2. 解锁`happens-before`加锁
 3. `volatile`写 `happens-before` `volatile`读
 4. 传递性: A->B, B->C ，则A->C
 5. 如果线程A 启动线程B(threadB.start()), 那么A的这个启动操作-> 线程B的任意操作
 6. 如果线程A在线程B.join()成功返回，那么线程B中的任意操作->线程A的join()操作。



***原子操作:*** 意思为不可分割的一个或者一系列操作。

`处理器实现原子操作的方式`:
 * 通过总线锁，发生lock前缀的指令，在对共享变量改的时候其他处理器不能访问，开销较大，其他处理器不能访问其他内存
 * 锁缓存， 在高速缓存中修改，修改共享的内存地址，其他处理器发现后会将自己的缓存失效重新到主存中读取。

`java实现原子操作的方式:`
 * 自旋（死循环）+ CAS 知道成功为止, jvm的cas依托于处理器实现。

---

#### 本篇介绍了java并发技术实现的的基础知识以及原理，下篇讲述内存模型！

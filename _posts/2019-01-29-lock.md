---
layout: post
title:  "Java并发之锁Lock"
categories: concurrent
tags:  concurrent
author: Lzg
---

* content
{:toc}

---

# java并发之锁Lock

上面在解读了AQS的原理和作用之后，本篇开始讲解一下JUC锁相关的知识，其底层实现是基于AQS，只要理解了AQS，再看显示锁的实现就很容易了。在Java中显示锁有重入锁，读写锁。

**可重入锁ReentrantLock**
可重入锁作为隐式锁`synchronized`的一种补充，提供了额外的一些功能。
 1. 响应中断, 对客户端暴露`lockInterruptibly`， 里面实现则是委托给`AQS`的`acquireInterruptibly`
 2. 尝试性获取锁`tryLock`,  实现是通过CAS去设置State，如果成功则返回true，失败则false
 3. 限时的获取锁,  底层通过`AQS`的`tryAcquireNanos`代理实现。
 4. 支持公平锁, 获取锁的顺序严格按照FIFO模型，等待锁时间越长的线程最先获取锁(实现放下面说)

代码实例:
```java
  //不要放进try块，以为出异常会进行unlock，这样会抛异常(因为只有获取到锁才能释放)。
  Lock lock = new ReentrantLock();  
  try {
    ///some code...
  } finally {
    lock.unlock();
  }
```

具体实现:
内部通过state=0表示未被持有，1表示被线程持有锁。首先看下非公平锁的获取锁过程:
```java
final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            // 锁空闲
            if (c == 0) {
              // cas设置状态
                if (compareAndSetState(0, acquires)) {
                    // 成功则将锁独占
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            // 如果锁被持有了并且是当前线程，则可以再次获得，可重入的实现
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
```
锁的释放:
```java
public final boolean release(int arg) {
       if (tryRelease(arg)) {
           Node h = head;
           if (h != null && h.waitStatus != 0)
              // 唤醒后置节点(被park了，现在unpark，重新去获取同步状态)
               unparkSuccessor(h);
           return true;
       }
       return false;
   }
        // tryRelease代码 ↓
        int c = getState() - releases;
         if (Thread.currentThread() != getExclusiveOwnerThread())
             throw new IllegalMonitorStateException();
         boolean free = false;
         //修改状态为0,因为是释放独占锁，所有不需要cas，因为只可能有一个线程会释放
         if (c == 0) {
             free = true;
             setExclusiveOwnerThread(null);
         }
         setState(c);
         return free;
```

**公平锁 or 非公平锁？**

效率：公平锁在效率上不如非公平锁，因为公平锁会带来更多的上下文切换，而非公平锁则不会，这是因为往往一个已经获得了锁的线程在去重新竞争锁资源的时候往往成功率更高，同时非公平锁减少了线程被挂起的几率，也就减少了上下文的切换。


非公平锁实现方式: 非公平锁在lock的时候会先去尝试获取同步状态，失败的话则进行`tryAcquire`
```java
        final void lock() {
          // 尝试获取同步状态
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
```        
而公平锁则不会尝试，直接进行`acquire`
```java
      final void lock() {
          acquire(1);
      }
```

在`acquire`模板方法里，分别都是实现`tryAcquire`。 他们的唯一区别就是公平锁会判断是否有前置节点或者等待对列为空

```java
protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
              // 这里会加入判断是否有前驱节点，有就代表存在比当前等待时间更长的线程
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
```        

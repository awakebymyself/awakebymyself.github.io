---
layout: post
title:  "mybatis源码解读（二）"
categories: mybatis源码解读
tags:  tech
author: Lzg
---

* content
{:toc}

---

# mybatis源码解读之答疑
我认为阅读源码最好的方式是带着问题去阅读，在过程中解决疑惑，也可以学习下设计，代码的组织结构等等，其乐无穷啊。下面我就将阅读源码之后解决的问题都列出来，以供复习回忆，就不一一分析源代码了，Mybatis 的源码还是很简洁易懂的。


**mybatis如何处理结果集映射(resultMap和resultSet)以及延迟加载？**

在`DefaultResultSetHandler`中`handleResultSet`中
```java
private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List<Object> multipleResults, ResultMapping parentMapping) throws SQLException {
   try {
     if (parentMapping != null) {
       handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);
     } else {
       if (resultHandler == null) {
         DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);
         handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);
         multipleResults.add(defaultResultHandler.getResultList());
       } else {
         handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);
       }
     }
   } finally {
     // issue #228 (close resultsets)
     closeResultSet(rsw.getResultSet());
   }
 }
```
如果是简单的resultMap(没有内联的resultMap/resultType)，进入else语句
跟进去代码最终里层处理是在这边

```java
private boolean applyPropertyMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, ResultLoaderMap lazyLoader, String columnPrefix)
     throws SQLException {
   final List<String> mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix);
   boolean foundValues = false;

   获取配置的resultMap里面每个result的信息，包括列名，字段名，对应的typeHandler(解析resultMap的时候生成进去的),
   final List<ResultMapping> propertyMappings = resultMap.getPropertyResultMappings();
   for (ResultMapping propertyMapping : propertyMappings) {
     String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);
     if (propertyMapping.getNestedResultMapId() != null) {
       // the user added a column attribute to a nested result map, ignore it
       column = null;
     }
     if (propertyMapping.isCompositeResult()
         || (column != null && mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH)))
         || propertyMapping.getResultSet() != null) {
        通过resultSet和列名以及handler将这个列对应的值取出来
       Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix);
       // issue #541 make property optional
       final String property = propertyMapping.getProperty();
       if (property == null) {
         continue;
       } else if (value == DEFERED) {
         foundValues = true;
         continue;
       }
       if (value != null) {
         foundValues = true;
       }
       if (value != null || (configuration.isCallSettersOnNulls() && !metaObject.getSetterType(property).isPrimitive())) {
         // gcode issue #377, call setter on nulls (value is not 'found')
         将这个数据库的值设置到对应的对象上去，然后继续while循环下一个值设置。
         这就是简单的resultMap的处理过程。
         metaObject.setValue(property, value);
       }
     }
   }
   return foundValues;
 ```

*对于有内联的resultMap*
首先`ResultMap` 对象中有一个属性`ResultMap  private List<ResultMapping> propertyResultMappings;
`保存内联的resultMap。
在进行对于的映射的时候是先对主对象设置，然后再对子对象进行设置,代码如下：

```java
private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, CacheKey combinedKey, String columnPrefix, Object partialObject) throws SQLException {
    final String resultMapId = resultMap.getId();
    Object rowValue = partialObject;
    if (rowValue != null) {
      final MetaObject metaObject = configuration.newMetaObject(rowValue);
      putAncestor(rowValue, resultMapId);
      applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, false);
      ancestorObjects.remove(resultMapId);
    } else {
      final ResultLoaderMap lazyLoader = new ResultLoaderMap();
      rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);
      if (rowValue != null && !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {
        final MetaObject metaObject = configuration.newMetaObject(rowValue);
        boolean foundValues = this.useConstructorMappings;
        if (shouldApplyAutomaticMappings(resultMap, true)) {
          foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;
        }
        设置主对象的属性
        foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;
        putAncestor(rowValue, resultMapId);
        设置子对象的属性
        foundValues = applyNestedResultMappings(rsw, resultMap, metaObject, columnPrefix, combinedKey, true) || foundValues;
        ancestorObjects.remove(resultMapId);
        foundValues = lazyLoader.size() > 0 || foundValues;
        rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null;
      }
      if (combinedKey != CacheKey.NULL_CACHE_KEY) {
        nestedResultObjects.put(combinedKey, rowValue);
      }
    }
    return rowValue;
  }
```

*如何实现延迟加载？*
`association`配置select和IsLazy
答案就是通过动态代理！
`DefaultResultHandler`中
```java
private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException {
    this.useConstructorMappings = false; // reset previous mapping result
    final List<Class<?>> constructorArgTypes = new ArrayList<Class<?>>();
    final List<Object> constructorArgs = new ArrayList<Object>();
    Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);
    if (resultObject != null && !hasTypeHandlerForResultObject(rsw, resultMap.getType())) {
      final List<ResultMapping> propertyMappings = resultMap.getPropertyResultMappings();
      for (ResultMapping propertyMapping : propertyMappings) {
        // issue gcode #109 && issue #149
        如果子resultMap需要延迟加载，那么就创建resultObject的代理对象，底层通过cglib和javassist
        if (propertyMapping.getNestedQueryId() != null && propertyMapping.isLazy()) {
          resultObject = configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);
          break;
        }
      }
    }
    this.useConstructorMappings = resultObject != null && !constructorArgTypes.isEmpty(); // set current mapping result
    return resultObject;
  }
```
*底层设置了callback最后会调用LoaderMap中的load获取信息*


**一级缓存也就是SqlSession级别缓存如何实现？**
